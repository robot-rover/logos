---
source: logos-codegen/tests/codegen.rs
expression: formatted
---
impl<'s> ::logos::Logos<'s> for Token {
    type Error = &'static str;
    type Extras = Vec<&'static str>;
    type Source = str;
    fn lex(
        lex: &mut ::logos::Lexer<'s, Self>,
    ) -> std::option::Option<std::result::Result<Self, Self::Error>> {
        use ::logos::internal::{
            LexerInternal, CallbackRetVal, CallbackResult, SkipRetVal, SkipResult,
        };
        use std::result::Result as _Result;
        use std::option::Option as _Option;
        use ::logos::Logos;
        type _Lexer<'s> = ::logos::Lexer<'s, Token>;
        macro_rules! _fast_loop {
            ($lex:ident, $test:ident, $offset:ident) => {
                'fast_loop : { while let Some(arr) = $lex .read:: < & [u8; 8usize] >
                ($offset) { if $test (arr[0usize]) { $offset += 0usize; break 'fast_loop;
                } if $test (arr[1usize]) { $offset += 1usize; break 'fast_loop; } if
                $test (arr[2usize]) { $offset += 2usize; break 'fast_loop; } if $test
                (arr[3usize]) { $offset += 3usize; break 'fast_loop; } if $test
                (arr[4usize]) { $offset += 4usize; break 'fast_loop; } if $test
                (arr[5usize]) { $offset += 5usize; break 'fast_loop; } if $test
                (arr[6usize]) { $offset += 6usize; break 'fast_loop; } if $test
                (arr[7usize]) { $offset += 7usize; break 'fast_loop; } $offset += 8usize;
                } while let Some(byte) = $lex .read:: < u8 > ($offset) { if $test (byte)
                { break 'fast_loop; } $offset += 1; } }
            };
        }
        macro_rules! _take_action {
            ($lex:ident, $offset:ident, $context:ident, $state:ident) => {
                { let action = _get_action($lex, $offset, $context); match action {
                CallbackResult::Emit(tok) => { return Some(Ok(tok)); },
                CallbackResult::Skip => { $lex .trivia(); $offset = $lex .offset();
                $context = 0usize; $state = LogosState::State0; continue; },
                CallbackResult::Error(err) => { return Some(Err(err)); },
                CallbackResult::DefaultError => { return Some(Err(_make_error($lex))); },
                } }
            };
        }
        #[inline]
        fn _make_error<'s>(lex: &mut _Lexer<'s>) -> <Token as Logos<'s>>::Error {
            <Token as Logos<'s>>::Error::default()
        }
        #[inline]
        fn _get_action<'s>(
            lex: &mut _Lexer<'s>,
            offset: usize,
            context: usize,
        ) -> CallbackResult<'s, Token> {
            match context {
                0 => {
                    lex.end_to_boundary(offset.max(lex.offset() + 1));
                    CallbackResult::Error(_make_error(lex))
                }
                1usize => CallbackResult::Skip,
                2usize => {
                    let cb_result = {
                        let lex = lex;
                        lex.extras.push("inline_callback")
                    };
                    let srv = SkipRetVal::<'s, Token>::construct(cb_result);
                    CallbackResult::from(srv)
                }
                3usize => {
                    let cb_result = labelled_callback(lex);
                    let srv = SkipRetVal::<'s, Token>::construct(cb_result);
                    CallbackResult::from(srv)
                }
                4usize => {
                    let cb_result = labelled_skip_callback(lex);
                    let srv = SkipRetVal::<'s, Token>::construct(cb_result);
                    CallbackResult::from(srv)
                }
                5usize => {
                    let cb_result = labelled_result_callback(lex);
                    let srv = SkipRetVal::<'s, Token>::construct(cb_result);
                    CallbackResult::from(srv)
                }
                6usize => {
                    let cb_result = labelled_skip_result_callback(lex);
                    let srv = SkipRetVal::<'s, Token>::construct(cb_result);
                    CallbackResult::from(srv)
                }
                _ => unreachable!(),
            }
        }
        #[derive(Clone, Copy)]
        enum LogosState {
            State0,
            State1,
            State2,
            State3,
            State4,
            State5,
            State6,
        }
        let mut state = LogosState::State0;
        let mut offset = lex.offset();
        let mut context = 0usize;
        loop {
            match state {
                LogosState::State0 => {
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {
                        const TABLE: [_Option<LogosState>; 256] = [
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some(LogosState::State2),
                            Some(LogosState::State3),
                            Some(LogosState::State4),
                            Some(LogosState::State5),
                            Some(LogosState::State6),
                            Some(LogosState::State6),
                            Some(LogosState::State1),
                            Some(LogosState::State1),
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                        ];
                        let next_state = TABLE[byte as usize];
                        if let Some(next_state) = next_state {
                            offset += 1;
                            state = next_state;
                            continue;
                        }
                    } else {
                        if lex.offset() == offset {
                            return None;
                        }
                    }
                    _take_action!(lex, offset, context, state)
                }
                LogosState::State1 => {
                    lex.end(offset);
                    context = 6usize;
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {} else {}
                    _take_action!(lex, offset, context, state)
                }
                LogosState::State2 => {
                    lex.end(offset);
                    context = 1usize;
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {} else {}
                    _take_action!(lex, offset, context, state)
                }
                LogosState::State3 => {
                    lex.end(offset);
                    context = 2usize;
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {} else {}
                    _take_action!(lex, offset, context, state)
                }
                LogosState::State4 => {
                    lex.end(offset);
                    context = 3usize;
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {} else {}
                    _take_action!(lex, offset, context, state)
                }
                LogosState::State5 => {
                    lex.end(offset);
                    context = 4usize;
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {} else {}
                    _take_action!(lex, offset, context, state)
                }
                LogosState::State6 => {
                    lex.end(offset);
                    context = 5usize;
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {} else {}
                    _take_action!(lex, offset, context, state)
                }
            }
        }
    }
}
