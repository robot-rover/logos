---
source: logos-cli/tests/tests.rs
expression: output
---
# [derive (Debug , Clone , Copy , PartialEq)] enum Token { Letter , }impl < 's > :: logos :: Logos < 's > for Token { type Error = () ; type Extras = () ; type Source = str ; fn lex (lex : & mut :: logos :: Lexer < 's , Self >) -> std :: option :: Option < std :: result :: Result < Self , Self :: Error >> { use :: logos :: internal :: { LexerInternal , CallbackRetVal , CallbackResult , SkipRetVal , SkipResult , } ; use std :: result :: Result as _Result ; use std :: option :: Option as _Option ; use :: logos :: Logos ; type _Lexer < 's > = :: logos :: Lexer < 's , Token > ; macro_rules ! _fast_loop { ($ lex : ident , $ test : ident , $ offset : ident) => { 'fast_loop : { while let Some (arr) = $ lex . read :: < & [u8 ; 8usize] > ($ offset) { if $ test (arr [0usize]) { $ offset += 0usize ; break 'fast_loop ; } if $ test (arr [1usize]) { $ offset += 1usize ; break 'fast_loop ; } if $ test (arr [2usize]) { $ offset += 2usize ; break 'fast_loop ; } if $ test (arr [3usize]) { $ offset += 3usize ; break 'fast_loop ; } if $ test (arr [4usize]) { $ offset += 4usize ; break 'fast_loop ; } if $ test (arr [5usize]) { $ offset += 5usize ; break 'fast_loop ; } if $ test (arr [6usize]) { $ offset += 6usize ; break 'fast_loop ; } if $ test (arr [7usize]) { $ offset += 7usize ; break 'fast_loop ; } $ offset += 8usize ; } while let Some (byte) = $ lex . read :: < u8 > ($ offset) { if $ test (byte) { break 'fast_loop ; } $ offset += 1 ; } } } ; } # [inline] fn _make_error < 's > (lex : & mut _Lexer < 's >) -> < Token as Logos < 's >> :: Error { < Token as Logos < 's >> :: Error :: default () } # [inline] fn _make_token < 's > (lex : & mut _Lexer < 's > , offset : usize , context : usize) -> CallbackResult < 's , Token > { match context { 0 => { lex . end_to_boundary (offset . max (lex . offset () + 1)) ; CallbackResult :: Error (_make_error (lex)) } , 1usize => { CallbackResult :: Emit (Token :: Letter) } _ => unreachable ! () , } } fn state0 < 's > (lex : & mut _Lexer < 's > , mut offset : usize , mut context : usize) -> _Option < _Result < Token , < Token as Logos < 's >> :: Error >> { let other = lex . read :: < u8 > (offset) ; if let Some (byte) = other { } else { } let action = _make_token (lex , offset , context) ; match action { CallbackResult :: Emit (tok) => { return Some (Ok (tok)) ; } , CallbackResult :: Skip => { lex . trivia () ; offset = lex . offset () ; context = 0usize ; return state2 (lex , offset , context) ; } , CallbackResult :: Error (err) => { return Some (Err (err)) ; } , CallbackResult :: DefaultError => { return Some (Err (_make_error (lex))) ; } , } } fn state1 < 's > (lex : & mut _Lexer < 's > , mut offset : usize , mut context : usize) -> _Option < _Result < Token , < Token as Logos < 's >> :: Error >> { let other = lex . read :: < u8 > (offset) ; if let Some (byte) = other { } else { } let action = _make_token (lex , offset , context) ; match action { CallbackResult :: Emit (tok) => { return Some (Ok (tok)) ; } , CallbackResult :: Skip => { lex . trivia () ; offset = lex . offset () ; context = 0usize ; return state2 (lex , offset , context) ; } , CallbackResult :: Error (err) => { return Some (Err (err)) ; } , CallbackResult :: DefaultError => { return Some (Err (_make_error (lex))) ; } , } } fn state2 < 's > (lex : & mut _Lexer < 's > , mut offset : usize , mut context : usize) -> _Option < _Result < Token , < Token as Logos < 's >> :: Error >> { let other = lex . read :: < u8 > (offset) ; if let Some (byte) = other { if (byte == b'a') { offset += 1 ; return state5 (lex , offset , context) ; } } else { if lex . offset () == offset { return None } } let action = _make_token (lex , offset , context) ; match action { CallbackResult :: Emit (tok) => { return Some (Ok (tok)) ; } , CallbackResult :: Skip => { lex . trivia () ; offset = lex . offset () ; context = 0usize ; return state2 (lex , offset , context) ; } , CallbackResult :: Error (err) => { return Some (Err (err)) ; } , CallbackResult :: DefaultError => { return Some (Err (_make_error (lex))) ; } , } } fn state3 < 's > (lex : & mut _Lexer < 's > , mut offset : usize , mut context : usize) -> _Option < _Result < Token , < Token as Logos < 's >> :: Error >> { let other = lex . read :: < u8 > (offset) ; if let Some (byte) = other { if (byte == b'z') { offset += 1 ; return state4 (lex , offset , context) ; } } else { } let action = _make_token (lex , offset , context) ; match action { CallbackResult :: Emit (tok) => { return Some (Ok (tok)) ; } , CallbackResult :: Skip => { lex . trivia () ; offset = lex . offset () ; context = 0usize ; return state2 (lex , offset , context) ; } , CallbackResult :: Error (err) => { return Some (Err (err)) ; } , CallbackResult :: DefaultError => { return Some (Err (_make_error (lex))) ; } , } } fn state4 < 's > (lex : & mut _Lexer < 's > , mut offset : usize , mut context : usize) -> _Option < _Result < Token , < Token as Logos < 's >> :: Error >> { lex . end (offset) ; context = 1usize ; let other = lex . read :: < u8 > (offset) ; if let Some (byte) = other { } else { } let action = _make_token (lex , offset , context) ; match action { CallbackResult :: Emit (tok) => { return Some (Ok (tok)) ; } , CallbackResult :: Skip => { lex . trivia () ; offset = lex . offset () ; context = 0usize ; return state2 (lex , offset , context) ; } , CallbackResult :: Error (err) => { return Some (Err (err)) ; } , CallbackResult :: DefaultError => { return Some (Err (_make_error (lex))) ; } , } } fn state5 < 's > (lex : & mut _Lexer < 's > , mut offset : usize , mut context : usize) -> _Option < _Result < Token , < Token as Logos < 's >> :: Error >> { let other = lex . read :: < u8 > (offset) ; if let Some (byte) = other { if (byte == b'-') { offset += 1 ; return state3 (lex , offset , context) ; } } else { } let action = _make_token (lex , offset , context) ; match action { CallbackResult :: Emit (tok) => { return Some (Ok (tok)) ; } , CallbackResult :: Skip => { lex . trivia () ; offset = lex . offset () ; context = 0usize ; return state2 (lex , offset , context) ; } , CallbackResult :: Error (err) => { return Some (Err (err)) ; } , CallbackResult :: DefaultError => { return Some (Err (_make_error (lex))) ; } , } } state2 (lex , lex . offset () , 0) } }
